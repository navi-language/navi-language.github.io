use std.{fs, net.http.{client.{HttpClient, Request}, Headers, OK}, str.StringBuffer};

use utils;

const target_file = "releases.md";
const repo = "navi-language/navi";
const page_size = 200;

const MEATADATA = `
---
title: Releases
editLink: false
---

<!-- 
    Do not change this file.
    It's generated by navi run script/generate-release.nv 
-->

`;

struct Release {
    name: string?,
    tag_name: string,
    html_url: string,
    prerelease: bool = false,
    body: string?,
}

fn fetch_releases() throws {
    // https://api.github.com/repos/navi-language/navi/releases
    let client = HttpClient.new();
    let release_url = `https://api.github.com/repos/${repo}/releases?per_page=${page_size}`;
    let headers = Headers.new();
    headers.set("User-Agent", "Navi-Release-Generator");

    let res = try client
        .request(Request
            .get(release_url)
            .set_headers(Headers.from_map({"User-Agent": "Navi-Release-Generator"})));
    if (res.status() != OK) {
        throw `Fetch releases failed: ${res.status()} ${res.headers()}`;
    }
    let releases = try! res.json::<[Release]>();

    let buf = StringBuffer.new();
    buf.push_string(MEATADATA);

    for (let release in releases) {
        // ignore pre-releases
        if (release.prerelease) {
            continue;
        }

        let body = release.body || "";
        if (body.is_empty()) {
            println(`Release ${release.tag_name} has no body, skiped.`);
            continue;
        }

        let name = release.name || "";
        if (name.is_empty()) {
            name = release.tag_name;
        }

        let html_url = release.html_url;
        let body = utils.format_doc(body, level: 2);
        buf.push_string(`## [${name}](${html_url})\n\n`);
        buf.push_string(`${body}\n\n`);
    }

    let f = try fs.create(target_file);
    defer {
        try! f.close();
    }
    try f.write_string(buf.to_string().trim());
}

fn main() throws {
    try fetch_releases();
    println("Generate releases success.");
}
